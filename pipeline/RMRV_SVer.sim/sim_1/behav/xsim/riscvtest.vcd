$date
   Tue Jan 28 22:04:00 2020
$end
$version
  2019.2
$end
$timescale
  1ps
$end
$scope module testbench $end
$scope module dut $end
$var wire 1 ! clk $end
$var wire 1 " reset $end
$var reg 32 # write_data [31:0] $end
$var reg 32 $ address [31:0] $end
$var reg 1 % memwrite $end
$var reg 32 & instruction [31:0] $end
$var reg 32 ' pc [31:0] $end
$var reg 32 ( read_data [31:0] $end
$scope module riscv $end
$var wire 1 ! clk $end
$var wire 1 " reset $end
$var reg 32 ' pc [31:0] $end
$var wire 32 ) instruction [31:0] $end
$var reg 1 % memwrite $end
$var reg 32 $ alu_result [31:0] $end
$var reg 32 # write_data [31:0] $end
$var wire 32 * read_data [31:0] $end
$var reg 1 + memtoreg $end
$var reg 1 , pcsrc $end
$var reg 1 - zero $end
$var reg 1 . alusrc $end
$var reg 1 / regwrite $end
$var reg 4 0 alu_operation [3:0] $end
$var wire 1 1 memread $end
$scope module c $end
$var wire 7 2 opcode [6:0] $end
$var wire 3 3 funct3 [2:0] $end
$var wire 7 4 funct7 [6:0] $end
$var wire 1 5 zero $end
$var reg 1 + memtoreg $end
$var reg 1 % memwrite $end
$var reg 1 6 memread $end
$var reg 1 , pcsrc $end
$var reg 1 . alusrc $end
$var reg 1 / regwrite $end
$var reg 4 0 alucontrol [3:0] $end
$var reg 2 7 aluop [1:0] $end
$var reg 1 8 branch $end
$scope module ctrl $end
$var wire 7 2 opcode [6:0] $end
$var reg 1 . alusrc $end
$var reg 1 + memtoreg $end
$var reg 1 / regwrite $end
$var reg 1 6 memread $end
$var reg 1 % memwrite $end
$var reg 1 8 branch $end
$var reg 2 7 aluop [1:0] $end
$var reg 8 9 controls [7:0] $end
$upscope $end
$scope module aluctrl $end
$var wire 2 : aluop [1:0] $end
$var wire 3 3 funct3 [2:0] $end
$var wire 7 4 funct7 [6:0] $end
$var reg 4 0 alucontrol [3:0] $end
$var reg 10 ; funct [9:0] $end
$upscope $end
$upscope $end
$scope module dp $end
$var wire 1 ! clk $end
$var wire 1 " reset $end
$var wire 1 < memtoreg $end
$var wire 1 = pcsrc $end
$var wire 1 > alusrc $end
$var wire 1 ? regwrite $end
$var wire 4 @ alu_operation [3:0] $end
$var reg 1 - zero $end
$var reg 32 ' pc [31:0] $end
$var wire 32 ) instruction [31:0] $end
$var reg 32 $ alu_result [31:0] $end
$var reg 32 # read_data2 [31:0] $end
$var wire 32 * read_data [31:0] $end
$var reg 32 A pre_pc [31:0] $end
$var reg 5 B writereg [4:0] $end
$var reg 32 C pcnext [31:0] $end
$var reg 32 D pcplus4 [31:0] $end
$var reg 32 E pcbranch [31:0] $end
$var reg 32 F read_data1 [31:0] $end
$var reg 32 G select_data [31:0] $end
$var reg 32 H result [31:0] $end
$var reg 32 I imm32 [31:0] $end
$var reg 32 J imm32_shiftleft1 [31:0] $end
$var reg 1 K branch_en $end
$var reg 3 L funct3 [2:0] $end
$scope module igen $end
$var wire 32 ) inst [31:0] $end
$var reg 32 I imm [31:0] $end
$var reg 32 M imm_i [31:0] $end
$var reg 32 N imm_s [31:0] $end
$var reg 32 O imm_b [31:0] $end
$upscope $end
$scope module rf $end
$var wire 1 ! clk $end
$var wire 1 ? reg_write $end
$var wire 5 P read_register1 [4:0] $end
$var wire 5 Q read_register2 [4:0] $end
$var wire 5 R write_register [4:0] $end
$var wire 32 S write_data [31:0] $end
$var reg 32 F read_data1 [31:0] $end
$var reg 32 # read_data2 [31:0] $end
$upscope $end
$scope module brcm $end
$var wire 32 T input_data1 [31:0] $end
$var wire 32 # input_data2 [31:0] $end
$var wire 3 U funct3 [2:0] $end
$var reg 1 K out $end
$upscope $end
$scope module pcbr $end
$var wire 1 ! clk $end
$var wire 1 " reset $end
$var wire 32 V jump_address [31:0] $end
$var wire 1 = branch $end
$var wire 1 W branch_en $end
$var reg 32 ' pc [31:0] $end
$var reg 32 X pc_reg [31:0] $end
$var reg 32 Y _pc [31:0] $end
$var reg 3 Z fuct3 [2:0] $end
$var reg 32 [ pcnext [31:0] $end
$var reg 32 \ pcplus4 [31:0] $end
$var reg 32 ] pcbranch [31:0] $end
$var reg 32 ^ imm32_shiftleft1 [31:0] $end
$upscope $end
$scope module alu $end
$var wire 4 @ alu_operation [3:0] $end
$var wire 32 _ input_data1 [31:0] $end
$var wire 32 ` input_data2 [31:0] $end
$var reg 32 $ alu_result [31:0] $end
$var reg 1 - zero $end
$upscope $end
$upscope $end
$upscope $end
$scope module imem $end
$var wire 32 a address [31:0] $end
$var reg 32 & read_data [31:0] $end
$upscope $end
$scope module dmem $end
$var wire 1 ! clk $end
$var wire 1 % memwrite $end
$var wire 32 $ address [31:0] $end
$var wire 32 # write_data [31:0] $end
$var reg 32 ( read_data [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
1!
1"
b0 #
b0 $
0%
b11000010000011 &
b0 '
b1010 (
b11000010000011 )
b1010 *
1+
0,
1-
1.
1/
b10 0
11
b11 2
b11 3
b0 4
15
16
b0 7
08
b11110000 9
b0 :
b11 ;
1<
0=
1>
1?
b10 @
bx A
bx B
bx C
bx D
bx E
b0 F
b0 G
b1010 H
b0 I
bx J
0K
b11 L
b0 M
b1 N
b100000000000 O
b0 P
b0 Q
b1 R
b1010 S
b0 T
b11 U
b0 V
0W
b0 X
b0 Y
bx Z
b100 [
b100 \
b0 ]
b0 ^
b0 _
b0 `
b0 a
$end
#5000
0!
0"
#10000
1!
bx #
b1000 $
b100000000011000100000011 &
b100 '
b11 (
b100000000011000100000011 )
b11 *
0,
0-
b11 2
b11 3
b0 4
05
b0 F
b1000 G
b11 H
b1000 I
0K
b1000 M
b10 N
b10 O
b0 P
b1000 Q
b10 R
b11 S
b1000 V
b1000 [
b1000 \
b10100 ]
b10000 ^
b1000 `
b100 a
#15000
0!
#20000
1!
bx #
b10000 $
b1000000000011000110000011 &
b1000 '
bx (
b1000000000011000110000011 )
bx *
0-
b11 2
b11 3
b0 4
b0 F
b10000 G
bx H
b10000 I
b10000 M
b11 N
b100000000010 O
b0 P
b10000 Q
b11 R
bx S
b10000 V
b100 Y
b1100 [
b1100 \
b101000 ]
b100000 ^
b10000 `
b1000 a
#25000
0!
#30000
1!
bx #
b11000 $
b1100000000011001000000011 &
b1100 '
bx (
b1100000000011001000000011 )
0-
b11 2
b11 3
b0 4
b11000 G
bx H
b11000 I
b11000 M
b100 N
b100 O
b0 P
b11000 Q
b100 R
b11000 V
b1000 Y
b10000 [
b10000 \
b111100 ]
b110000 ^
b11000 `
b1100 a
#35000
0!
#40000
1!
b11 #
b1101 $
b1000001000000010110011 &
b10000 '
bx (
b1000001000000010110011 )
0+
0,
0-
0.
1/
b10 0
01
b110011 2
b0 3
b0 4
05
06
b10 7
08
b100010 9
b10 :
b0 ;
0<
0>
b1010 F
b11 G
b1101 H
bx I
0K
b0 L
b10 M
b1 N
b100000000000 O
b1 P
b10 Q
b1 R
b1101 S
b1010 T
b0 U
bx V
b1100 Y
b10100 [
b10100 \
bx ]
bx0 ^
b1010 _
b11 `
b10000 a
#45000
0!
#50000
1!
bx #
bx $
b1000000010000011000000110110011 &
b10100 '
bx (
b1000000010000011000000110110011 )
0,
x-
b110 0
b110011 2
b0 3
b100000 4
x5
b100000000 ;
b110 @
bx F
bx G
bx H
bx I
xK
b10000000100 M
b10000000011 N
b110000000010 O
b11 P
b100 Q
b11 R
bx S
bx T
xW
b10000 Y
b11000 [
b11000 \
bx ]
bx _
bx `
b10100 a
#55000
0!
#60000
1!
b0 #
bx $
b11000010001100011 &
b11000 '
b11000010001100011 )
0+
x,
0.
0/
b110 0
b1100011 2
b0 3
b0 4
06
b1 7
18
b101 9
b1 :
b0 ;
x=
0?
b110 @
b0 G
b1000 I
xK
b0 M
b1000 N
b1000 O
b11 P
b0 Q
b1000 R
b1000 V
b10100 Y
b0xx1x00 [
b11100 \
b101000 ]
b10000 ^
b0 `
b11000 a
#65000
0!
#70000
1!
b0 $
b11111110000000000000101011100011 &
b11100 '
b1010 (
b11111110000000000000101011100011 )
b1010 *
1,
1-
b110 0
b1100011 2
b0 3
b1111111 4
15
b1111111000 ;
1=
b0 F
b0 G
b0 H
b11111111111111111111111111110100 I
1K
b11111111111111111111111111100000 M
b11111111111111111111111111110101 N
b11111111111111111111111111110100 O
b0 P
b0 Q
b10101 R
b0 S
b0 T
b11111111111111111111111111110100 V
1W
b11000 Y
b100 [
b100000 \
b100 ]
b11111111111111111111111111101000 ^
b0 _
b11100 a
#75000
0!
#80000
1!
bx #
b1000 $
b100000000011000100000011 &
b100 '
b11 (
b100000000011000100000011 )
b11 *
1+
0,
0-
1.
1/
b10 0
11
b11 2
b11 3
b0 4
05
16
b0 7
08
b11110000 9
b0 :
b11 ;
1<
0=
1>
1?
b10 @
b1000 G
b11 H
b1000 I
0K
b11 L
b1000 M
b10 N
b10 O
b0 P
b1000 Q
b10 R
b11 S
b11 U
b1000 V
0W
b11100 Y
b1000 [
b1000 \
b10100 ]
b10000 ^
b1000 `
b100 a
#85000
0!
#90000
1!
bx #
b10000 $
b1000000000011000110000011 &
b1000 '
bx (
b1000000000011000110000011 )
bx *
0-
b11 2
b11 3
b0 4
b10000 G
bx H
b10000 I
b10000 M
b11 N
b100000000010 O
b0 P
b10000 Q
b11 R
bx S
b10000 V
b100 Y
b1100 [
b1100 \
b101000 ]
b100000 ^
b10000 `
b1000 a
#95000
0!
#100000
1!
bx #
b11000 $
b1100000000011001000000011 &
b1100 '
bx (
b1100000000011001000000011 )
0-
b11 2
b11 3
b0 4
b11000 G
bx H
b11000 I
b11000 M
b100 N
b100 O
b0 P
b11000 Q
b100 R
b11000 V
b1000 Y
b10000 [
b10000 \
b111100 ]
b110000 ^
b11000 `
b1100 a
#105000
0!
#110000
1!
b11 #
b10000 $
b1000001000000010110011 &
b10000 '
bx (
b1000001000000010110011 )
0+
0,
0-
0.
1/
b10 0
01
b110011 2
b0 3
b0 4
05
06
b10 7
08
b100010 9
b10 :
b0 ;
0<
0>
b1101 F
b11 G
b10000 H
bx I
0K
b0 L
b10 M
b1 N
b100000000000 O
b1 P
b10 Q
b1 R
b10000 S
b1101 T
b0 U
bx V
b1100 Y
b10100 [
b10100 \
bx ]
bx0 ^
b1101 _
b11 `
b10000 a
#115000
0!
#120000
1!
bx #
bx $
b1000000010000011000000110110011 &
b10100 '
bx (
b1000000010000011000000110110011 )
0,
x-
b110 0
b110011 2
b0 3
b100000 4
x5
b100000000 ;
b110 @
bx F
bx G
bx H
bx I
xK
b10000000100 M
b10000000011 N
b110000000010 O
b11 P
b100 Q
b11 R
bx S
bx T
xW
b10000 Y
b11000 [
b11000 \
bx ]
bx _
bx `
b10100 a
#125000
0!
#130000
1!
b0 #
bx $
b11000010001100011 &
b11000 '
b11000010001100011 )
0+
x,
0.
0/
b110 0
b1100011 2
b0 3
b0 4
06
b1 7
18
b101 9
b1 :
b0 ;
x=
0?
b110 @
b0 G
b1000 I
xK
b0 M
b1000 N
b1000 O
b11 P
b0 Q
b1000 R
b1000 V
b10100 Y
b0xx1x00 [
b11100 \
b101000 ]
b10000 ^
b0 `
b11000 a
#135000
0!
#140000
1!
b0 $
b11111110000000000000101011100011 &
b11100 '
b1010 (
b11111110000000000000101011100011 )
b1010 *
1,
1-
b110 0
b1100011 2
b0 3
b1111111 4
15
b1111111000 ;
1=
b0 F
b0 G
b0 H
b11111111111111111111111111110100 I
1K
b11111111111111111111111111100000 M
b11111111111111111111111111110101 N
b11111111111111111111111111110100 O
b0 P
b0 Q
b10101 R
b0 S
b0 T
b11111111111111111111111111110100 V
1W
b11000 Y
b100 [
b100000 \
b100 ]
b11111111111111111111111111101000 ^
b0 _
b11100 a
#145000
0!
#150000
1!
bx #
b1000 $
b100000000011000100000011 &
b100 '
b11 (
b100000000011000100000011 )
b11 *
1+
0,
0-
1.
1/
b10 0
11
b11 2
b11 3
b0 4
05
16
b0 7
08
b11110000 9
b0 :
b11 ;
1<
0=
1>
1?
b10 @
b1000 G
b11 H
b1000 I
0K
b11 L
b1000 M
b10 N
b10 O
b0 P
b1000 Q
b10 R
b11 S
b11 U
b1000 V
0W
b11100 Y
b1000 [
b1000 \
b10100 ]
b10000 ^
b1000 `
b100 a
#155000
0!
#160000
1!
bx #
b10000 $
b1000000000011000110000011 &
b1000 '
bx (
b1000000000011000110000011 )
bx *
0-
b11 2
b11 3
b0 4
b10000 G
bx H
b10000 I
b10000 M
b11 N
b100000000010 O
b0 P
b10000 Q
b11 R
bx S
b10000 V
b100 Y
b1100 [
b1100 \
b101000 ]
b100000 ^
b10000 `
b1000 a
#165000
0!
#170000
1!
bx #
b11000 $
b1100000000011001000000011 &
b1100 '
bx (
b1100000000011001000000011 )
0-
b11 2
b11 3
b0 4
b11000 G
bx H
b11000 I
b11000 M
b100 N
b100 O
b0 P
b11000 Q
b100 R
b11000 V
b1000 Y
b10000 [
b10000 \
b111100 ]
b110000 ^
b11000 `
b1100 a
#175000
0!
#180000
1!
b11 #
b10011 $
b1000001000000010110011 &
b10000 '
bx (
b1000001000000010110011 )
0+
0,
0-
0.
1/
b10 0
01
b110011 2
b0 3
b0 4
05
06
b10 7
08
b100010 9
b10 :
b0 ;
0<
0>
b10000 F
b11 G
b10011 H
bx I
0K
b0 L
b10 M
b1 N
b100000000000 O
b1 P
b10 Q
b1 R
b10011 S
b10000 T
b0 U
bx V
b1100 Y
b10100 [
b10100 \
bx ]
bx0 ^
b10000 _
b11 `
b10000 a
#185000
0!
#190000
1!
bx #
bx $
b1000000010000011000000110110011 &
b10100 '
bx (
b1000000010000011000000110110011 )
0,
x-
b110 0
b110011 2
b0 3
b100000 4
x5
b100000000 ;
b110 @
bx F
bx G
bx H
bx I
xK
b10000000100 M
b10000000011 N
b110000000010 O
b11 P
b100 Q
b11 R
bx S
bx T
xW
b10000 Y
b11000 [
b11000 \
bx ]
bx _
bx `
b10100 a
#195000
0!
#200000
1!
b0 #
bx $
b11000010001100011 &
b11000 '
b11000010001100011 )
0+
x,
0.
0/
b110 0
b1100011 2
b0 3
b0 4
06
b1 7
18
b101 9
b1 :
b0 ;
x=
0?
b110 @
b0 G
b1000 I
xK
b0 M
b1000 N
b1000 O
b11 P
b0 Q
b1000 R
b1000 V
b10100 Y
b0xx1x00 [
b11100 \
b101000 ]
b10000 ^
b0 `
b11000 a
